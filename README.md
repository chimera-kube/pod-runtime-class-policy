Continuous integration | License
 -----------------------|--------
![Continuous integration](https://github.com/chimera-kube/pod-runtime-class-policy/workflows/Continuous%20integration/badge.svg) | [![License: Apache 2.0](https://img.shields.io/badge/License-Apache2.0-brightgreen.svg)](https://opensource.org/licenses/Apache-2.0)

This directory contains a Chimera policy written using Swift.

# The goal

Given the following scenario:

> As an operator of a Kubernetes cluster used by multiple groups of user,
> I want to run untrusted workloads using a more secure container runtime.

Kubernetes has the concept of [Container Runtime Interfaces](https://kubernetes.io/docs/setup/production-environment/container-runtimes/)
which provides the flexibility to execute workloads using different container
engines.
Once properly configured, a Kubernetes cluster can run its workloads using
different runtimes.

On top of that, each Pod can define which Container Runtime has to be used
thanks to the [Runtime Class](https://kubernetes.io/docs/concepts/containers/runtime-class/)
attribute.

For example: trusted workloads could be executed with the "classical" runC,
while untrusted ones could be ran using a container engine that has a
strong focus on security, like [Kata Containers](https://katacontainers.io/)
or [gVisor](https://gvisor.dev/).

Unfortunately Kubernetes doesn't have any built-in mechanism that can force
untrusted users to use only pre-approved container runtimes..

This policy inspects the [AdmissionReview](https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/#request)
objects generated by the Kubernetes API server and either accept or reject
them.

The policy can be used to inspect `CREATE` and `UPDATE` requests of
`Pod` resources.

## Examples

Let's assume our cluster has two Runtime classes defined:

  * `containerd-runc`: containerD uses runC to start containers. This is the
    default runtime class. Workloads that do not specify a Runtime class
    will automatically use it.
  * `containerd-kata`: containerD uses the Kata Containers runtime to
    start containers.

Let's assume we have two set of users who have access to this cluser:

  * `trusted-users`: they can schedule workloads with any kind of runtime class
  * `untrusted-users`: they can schedule workloads only with the `containerd-kata`
    runtime

The following Pod specification doesn't have any runtime class specified:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
```

Such a workload should be schedulable only by users who belong to the `trusted-users`
group.

This Pod specification has instead the runtime class set to be `containerd-runc`:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  runtimeClassName: containerd-runc
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
```

Also in this case, the Pod must be schedulable only by users who belong to the
`trusted-users` group.

Finally, this Pod specification has instead the runtime class set to be `containerd-kata`:

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  runtimeClassName: containerd-kata
  containers:
  - name: nginx
    image: nginx
    imagePullPolicy: IfNotPresent
```

In this case the Pod can be scheduled by all users, regardless of the group they
belong to.

# Configuration

The policy behaviour can be influenced by these environment variables:

  * `RESERVED_RUNTIME`: the name of runtime class that should be limited only to
    workloads started by trusted users/groups. Required.
  * `DEFAULT_RUNTIME_RESERVED`: mark the default runtime class, the one used when
    the workloads doesn't specify a `runtimeClassName`, as a reserved one. True
    by default. Can be changed setting a value different from `1`.
  * `TRUSTED_USERS`: comma separated list of users who are allowed to use
    the reserved runtime. Optional.
  * `TRUSTED_GROUPS`: comma separated list of groups who are allowed to use
    the reserved runtime. Optional.

# Building

This policy is written using [Swiftwasm](https://book.swiftwasm.org/).
Build relies on the toolchain provided by the Swiftwasm project via container
image. Hence either docker or podman have to be installed.

Use this command to build the Wasm code in debugging mode:

```
$ make build
```

This will produce a `.wasm` file under `.build/debug/policy.wasm`.

The code can be built in release mode by using the following command:

```
$ make release
```

# Trying the policy

The policy is a stand-alone Wasm module, you can invoke it in this way:

```bash
$ cat Tests/Examples/PodRequestWithRuncRuntime.json | wasmtime run --env RESERVED_RUNTIME=runC \
              --env TRUSTED_USERS="alice,bob" \
              --env TRUSTED_GROUPS="system:authenticated" policy.wasm
```

This will produce the following output:

```bash
{"accepted":true,"message":""}
```

# Testing

Unit tests can be run via:

```bash
$ make test
```

# Benchmark

Some benchmarks can be run via this commnad:

```
$ make bench
```

The benchmarks rely on [hyperfine](https://github.com/sharkdp/hyperfine). The
make file will automatically install it using [Cargo](https://doc.rust-lang.org/cargo/).
